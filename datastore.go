package db

import (
	"context"
	"time"

	"google.golang.org/appengine/datastore"
)

type Clock func() time.Time

type Entity interface {
	HasKey() bool
	Key() *datastore.Key
	SetKey(*datastore.Key)
	Parent() *datastore.Key
	SetParent(*datastore.Key)
	SetCreatedAt(time.Time)
	StringId() string
	SetStringId(string) error
}

// Datastore Service that provides a set of
// operations to make it easy on you when
// working with appengine datastore
//
// It works along with db.Model in order to
// provide its features.
//
type Datastore struct {
	context     context.Context
	Clock       Clock
	KeyResolver *KeyResolver
}

// NewDatastore creates a new instance of Datastore
// with default Clock and KeyResolver
func NewDatastore(c context.Context) Datastore {
	return Datastore{
		context:     c,
		Clock:       time.Now,
		KeyResolver: NewKeyResolver(c),
	}
}

// Create creates a new entity in datastore
// using the key generated by the keyProvider
func (this Datastore) Create(e Entity) error {
	if err := this.AssignNewKey(e); err != nil {
		return err
	}

	e.SetCreatedAt(this.Clock())
	key, err := datastore.Put(this.context, e.Key(), e)
	e.SetKey(key)

	return err
}

// CreateAll creates entities in batch
func (this Datastore) CreateAll(es ...Entity) error {
	keys := make([]*datastore.Key, len(es))
	for i, e := range es {
		if err := this.AssignNewKey(e); err != nil {
			// rollback changes to created at of previous entities
			for j := i; j >= 0; j-- {
				es[j].SetCreatedAt(time.Time{})
			}
			return err
		}
		keys[i] = e.Key()
		e.SetCreatedAt(this.Clock())
	}
	generatedKeys, err := datastore.PutMulti(this.context, keys, es)
	for i, k := range generatedKeys {
		es[i].SetKey(k)
	}
	return err
}

// Update updated an entity in datastore
func (this Datastore) Update(e Entity) error {
	if _, err := this.ResolveKey(e); err != nil {
		return err
	}
	_, err := datastore.Put(this.context, e.Key(), e)
	return err
}

// UpdateAll updates entities in batch
func (this Datastore) UpdateAll(es ...Entity) error {
	keys := make([]*datastore.Key, len(es))
	for i, e := range es {
		if _, err := this.ResolveKey(e); err != nil {
			return err
		}
		keys[i] = e.Key()
	}
	_, err := datastore.PutMulti(this.context, keys, es)
	return err
}

// Load loads entity data from datastore
func (this Datastore) Load(e Entity) error {
	if _, err := this.ResolveKey(e); err != nil {
		return err
	}
	return datastore.Get(this.context, e.Key(), e)
}

// LoadAll loads entities in batch from datastore resolving
// their respective keys
func (this Datastore) LoadAll(es ...Entity) error {
	keys := make([]*datastore.Key, len(es))
	for i, e := range es {
		if _, err := this.ResolveKey(e); err != nil {
			return err
		}
		keys[i] = e.Key()
	}
	return datastore.GetMulti(this.context, keys, es)
}

// Delete deletes an entity from datastore
func (this Datastore) Delete(e Entity) error {
	if _, err := this.ResolveKey(e); err != nil {
		return err
	}
	return datastore.Delete(this.context, e.Key())
}

func (this Datastore) DeleteAll(es ...Entity) error {
	keys := make([]*datastore.Key, len(es))
	for i, e := range es {
		if _, err := this.ResolveKey(e); err != nil {
			return err
		}
		keys[i] = e.Key()
	}
	return datastore.DeleteMulti(this.context, keys)
}

// Query returns an instance of Querier
func (this Datastore) Query(q *Query) *Querier {
	return &Querier{this.context, q}
}

// AssignNewKey generates a new datastore key for the given entity
//
// The Key components are derived from the entity struct through reflection
//
// Fields tagged with `db:"id"` are used in the key as a StringID if
// the field type is string, or IntID in case its type is any int type
//
// In case multiple fields are tagged with `db:"id"`, the first field
// is selected to be used as id in the key
//
// If no field is tagged, the key is generated using the default values
// for StringID and IntID, causing the key to be auto generated by datastore
func (this Datastore) AssignNewKey(e Entity) error {
	_, err := this.KeyResolver.Resolve(e)
	return err
}

// ResolveKey assembles the key for the given entity based
// on its struct tags
//
// ErrMissingAutoGeneratedKey is returned in case the struct
// has no db:"id" tag and no key already assigned
func (this Datastore) ResolveKey(e Entity) (*Metadata, error) {
	if e.HasKey() {
		return KeyMetadata(e.Key()), nil
	}

	metadata, err := this.KeyResolver.Resolve(e)
	if err != nil {
		return nil, err
	}

	if metadata.IsAutoGenerated() {
		e.SetKey((*datastore.Key)(nil))
		return nil, ErrMissingAutoGeneratedKey
	}

	return metadata, nil
}
